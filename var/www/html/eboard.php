<?php
/***********************************************************
 * Get eboard slides
 * called from eboard.js as a jquery ajax call (getJSON)
 * no parameters
 * returns a json array containing:
 *   success (boolean):
 *     true: result is displayed
 *     false: result is discarded
 *   slides (array):
 *     each item is html text representing a slide
 *     slides are cycled within the main div of eboard.html
 *     html is generated by the phtml template files
 ***********************************************************/
$slides = array();

if (isset($_GET['date'])) {
    $date = new DateTimeImmutable($_GET['date']);
} else {
    $date = new DateTimeImmutable(NULL);
}
$filter = TRUE;
$limit = 8;

// get an array of events for the day limited to those nearest the current time
$daysEvents = getDailyCalendar($date, $filter, $limit);
ob_start();
require 'dailySlide.phtml';
$slides[] = ob_get_clean();

/* Here's where additional slides are generated (for instance on a sunday)
if ($date->format('l') === 'Sunday' || (isset($_GET['showWeek']) && $_GET['showWeek'] === 'true')) {
    $weeksEvents = getWeeklyHighlights($date, isset($_GET['addSamples']) && $_GET['addSamples'] === 'true');
    ob_start();
    require 'weeklySlide.phtml';
    $slides[] = ob_get_clean();
}
*/

$result = array(
    'success' => TRUE,
    'slides' => $slides
    );
echo json_encode(json_encode($result)); // why twice? otherwise, js error


/***********************************************************
 * Get daily calendar events (meeting filter requirements)
 * parameters:
 *   date (dateTime): date to fetch
 *   filter (boolean): turn filter on/off for testing
 *   limit (integer): max events that fit on display
 *   (remove the most distant if over limit)
 * returns an array of events containing
 * (or FALSE on failure):
 *   time (dateTime)
 *   name (text)
 *   location (text)
 ***********************************************************/
function getDailyCalendar($date, $filter, $limit) {

    $filename = '/tmp/dailyCalendar.json';
    // say file date is yesterday
    // so if file doesn't exist, it'll be expired by date
    $fileDate = new DateTime('yesterday');
    if (file_exists($filename)) {
        // update to actual file date
        $fileDate->setTimestamp(filemtime($filename));
    }
    // create an expiration date for time comparison
    $expirationDate = $date->sub(new DateInterval('PT10M'));
    $expiredByTime = FALSE;
    if ($fileDate <= $expirationDate) $expiredByTime = TRUE; // file is at least 10 minutes old
    // remove time portion for day comparison
    $fileDate->setTime(0, 0);
    $todaysDate = $date->setTime(0, 0);
    $expiredByDate = FALSE;
    if ($fileDate < $todaysDate) $expiredByDate = TRUE; // file is from yesterday
    if ($expiredByTime || $expiredByDate) {
        // file is expired, get data from acs
        $acsEvents = getAcsEvents($date->format('m/d/Y'), $date->format('m/d/Y'));
        if ($acsEvents) {
            // connected successfully
            file_put_contents($filename, json_encode($acsEvents));
        } else {
            // couldn't connect with server, use the file if it's not from yesterday
            if (!$expiredByDate) $acsEvents = json_decode(file_get_contents($filename), TRUE);
        }
    } else {
        // file is fresh, no need to connect with acs
        $acsEvents = json_decode(file_get_contents($filename), TRUE);
    }
    if($acsEvents === FALSE) return FALSE;

    // create an array, filtering out events that shouldn't display
    $events = array();
    foreach ($acsEvents as $event) {
        if (!$filter || (
            $event['Location']
            && $event['IsPublished']
//            && stripos($event['EventName'], 'oasis') === FALSE
//            && stripos($event['EventName'], 'staff meeting') === FALSE)
        ) {
            $events[$event['EventId']] = array(
                'time' => new DateTime($event['StartDate']),
                'endTime' => new DateTime($event['StopDate']),
                'name' => trim($event['EventName']),
                'location' => trim($event['Location']),
            );
        }
    }

    // if there are too many events, filter out the ones most distant in time
    if (count($events) > $limit) {
        $events = limitEvents($events, $date, $limit);
    }

    return $events;
}

/***********************************************************
 * Get weekly calendar highlights (tagged in note field)
 * parameters:
 *   date (dateTime): start date for the week
 * returns an array of events containing:
 *   date (dateTime)
 *   name (text)
 *   description (text)
 *   note (text)
 ***********************************************************/
function getWeeklyHighlights($start, $addSamples = false) {
    $stop = $start->add(new DateInterval('P7D'));
    $acsEvents = getAcsEvents($start->format('m/d/Y'), $stop->format('m/d/Y'));
    $events = array();
    foreach ($acsEvents as $event) {
        if (trim($event['Note'] && stripos($event['EventName'], "Men's Prayer Brkft") === FALSE)) {
            $events[] = array(
                'date' => new DateTime($event['StartDate']),
                'name' => trim($event['EventName']),
                'description' => trim($event['Description']),
                'note' => trim($event['Note']),
            );
        }
    }

    if ($addSamples) {
        $events[] = array(
            'date' => new DateTime('2017-05-28'),
            'name' => 'Summer Schedule Begins',
            'note' => 'Worship at 9:30 (no Faith Formation classes)',
        );
        $events[] = array(
            'date' => new DateTime('2017-06-04'),
            'name' => 'Graduate Recognition',
            'note' => "We'll recognize those graduating from High School, college and graduate school at the 9:30 worship service",
        );
        $events[] = array(
            'date' => new DateTime('2017-06-19 9 AM'),
            'name' => 'Vacation Bible School Begins',
            'note' => '"Hero Qualities" June 19 -23, 9 AM - Noon',
        );
    }

    return $events;
}

/***********************************************************
 * Get ACS events through accessacs api
 * uses curl for the request
 * use ssmtp mail to send a text message on error (disabled)
 * parameters:
 *   startDate (text): start date (inclusive)
 *   stopDate (text): stop date (inclusive)
 * returns an array of acs events containing (all text)
 * (or FALSE on failure):
 *   Description
 *   EventDateId
 *   EventId
 *   EventName
 *   EventType
 *   EventTypeId
 *   IsPublished
 *   LocationId
 *   Location
 *   StartDate
 *   StopDate
 *   Status
 *   CalendarName
 *   IsRecurringEvent
 *   CalendarId
 *   AllowRegistration
 *   DateModified
 *   Note
 ***********************************************************/
function getAcsEvents($startDate, $stopDate) {
    require '../config/acsUser.php';
    $url = 'https://secure.accessacs.com/api_accessacs_mobile/v2/' . $id . '/events?';
    $url .= '&startdate=' . $startDate;
    $url .= '&stopdate=' . $stopDate;
    $url .= '&pageSize=500';
    # keep total timeout (30s) below fastcgi_read_timeout (default 60s)
    $connectTimeout = 10;
    $retrieveTimeout = 20;

    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $connectTimeout);
    curl_setopt($ch, CURLOPT_TIMEOUT, $retrieveTimeout);
    curl_setopt($ch, CURLOPT_USERPWD, $username . ':' . $password);
    $jsonData = curl_exec($ch);
    if(!$jsonData) {
        $error = curl_error($ch);
        $errno = curl_errno($ch);
        curl_close($ch);
//        mail($email, 'Curl Error: ' . $errno, $error);
        return FALSE;
    }
    curl_close($ch);

    $data = json_decode($jsonData, TRUE);
    $events = $data['Page'];
    return $events;
}

/***********************************************************
 * Limit the events for display
 * remove events furthest from the current time
 * parameters:
 *   events (array): original array (following fields required)
 *     time: start time
 *     endTime: end time
 *   date (dateTime): current date/time
 *   limit (integer): max allowed
 * returns the original array minus the events furthest
 * from the current time
 ***********************************************************/
function limitEvents($events, $date, $limit) {
    $distances = array();
    foreach ($events as $id => $event) {
        // create the diffs (negative is past)
        $startDiff = $event['time']->getTimestamp() - $date->getTimestamp();
        $endDiff = $event['endTime']->getTimestamp() - $date->getTimestamp();
        // an event is either current, past or future, can't be anything else
        // assume it's a current event
        $distance = 0;
        // negative end diff: past event - weight by time since ended
        if ($endDiff < 0) {
            $distance = -$endDiff;
        }
        // positive start diff: future event - weight by time until start
        if ($startDiff > 0) {
            $distance = $startDiff;
        }
        $distances[$id] = $distance;
    }
    // reverse sort preserving keys
    arsort($distances);
    $delete = count($events) - $limit;
    $delCount = 0;
    foreach ($distances as $id => $distance) {
//        $events[$id]['distance'] = $distance;
        unset($events[$id]);
        $delCount++;
        if ($delCount >= $delete) {
            break;
        }
    }

    return $events;
}
